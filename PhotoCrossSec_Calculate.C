// PhotoCrossSec_Calculate.c
// David Grund, Sep 21, 2021

// cpp headers
#include <fstream>  // print output to txt file
#include <iomanip>  // std::setprecision()
#include <string>   // getline
// root headers
#include "TMath.h"
// my headers
#include "AnalysisManager.h"
#include "AnalysisConfig.h"
#include "SetPtBinning.h"

//*************************************************
// Cross section in pT^2 bins
Double_t N_yield_val[5] = { 0 };
Double_t N_yield_err[5] = { 0 };
Double_t Pt2Widths[5] = { 0 };
Double_t AxE_val[5] = { 0 };
Double_t AxE_err[5] = { 0 };
Double_t CorrFD_val[5] = { 0 };
Double_t CorrFD_err[5] = { 0 };
Double_t CorrFC_val[5] = { 0 };
Double_t CorrFC_err[5] = { 0 };
Double_t Sigma_UPC_val[5] = { 0 };
Double_t Sigma_UPC_err_stat[5] = { 0 };
Double_t Sigma_UPC_err_syst[5] = { 0 };
Double_t Sigma_photo_val[5] = { 0 };
Double_t Sigma_photo_err_stat[5] = { 0 };
Double_t Sigma_photo_err_syst[5] = { 0 };
Double_t t_avg_val[5] = { 0 };
//*************************************************
// Systematic uncertainties (in percent)
Double_t ErrSyst_SigExtr[5] = { 0 };
Double_t ErrSyst_AxE[5] = { 0 };
Double_t ErrSyst_fD[5] = { 0 };
Double_t ErrSyst_fC[5] = { 0 };
Double_t ErrSyst_lumi = 2.7;
Double_t ErrSyst_veto = 3.0;
Double_t ErrSyst_EMD = 2.0;
Double_t ErrSyst_tracks = 2.8;
Double_t ErrSyst_CCUP31 = 1.3;
Double_t ErrSyst_flux = 2.0;
//*************************************************
Double_t Lumi_val = 0; // 1/(mu barn)
Double_t Lumi_err = 0; // 1/(mu barn)
Double_t BR_val = 0.05961;
Double_t BR_err = 0.00033;
Double_t ErrSyst_BR = BR_err / BR_val * 100.;
Double_t RapWidth = 1.6;
Double_t Eff_veto_val = 94.0;
Double_t Eff_veto_err = Eff_veto_val * ErrSyst_veto / 100.;
Double_t Eff_EMD_val = 92.0;
Double_t Eff_EMD_err = Eff_EMD_val * ErrSyst_EMD / 100.;
Double_t PhotonFlux_val = 84.9;
Double_t PhotonFlux_err = PhotonFlux_val * ErrSyst_flux / 100.;
//*************************************************

Int_t i_bin;

void CalculateCrossSec_PtBins();
void PrintErr(TString str);

void PhotoCrossSec_Calculate(Int_t iAnalysis)
{
    InitAnalysis(iAnalysis);

    gSystem->Exec("mkdir -p Results/" + str_subfolder + "PhotoCrossSec/");

    CalculateCrossSec_PtBins();

    return;
}

void CalculateCrossSec_PtBins()
{
    SetPtBinning();

    ifstream ifs;

    Printf("Calculating the (photonuclear) cross section in %i pT bins.", nPtBins);

    //#####################################################################################################
    // 1) Load integrated luminosity for both periods
    Double_t Lumi_periods[2] = { 0 };
    TString str_period[2] = {"18q", "18r"};
    for(Int_t iPeriod = 0; iPeriod < 2; iPeriod++)
    {
        TString str_lumi = Form("Results/" + str_subfolder + "Lumi/lumi_%s.txt", str_period[iPeriod].Data());
        ifs.open(str_lumi.Data());
        // Read data from the file
        if(!ifs.fail()){
            ifs >> Lumi_periods[iPeriod];
        } else {
            PrintErr(str_lumi);
            return;
        }
        ifs.close(); 
    }
    Lumi_val = Lumi_periods[0] + Lumi_periods[1];
    Lumi_err = Lumi_val * ErrSyst_lumi / 100.;

    Printf("1) Integrated lumi loaded.");

    //#####################################################################################################
    // 2) Load N_yield per pT bin
    for(Int_t iBin = 0; iBin < nPtBins; iBin++)
    {
        TString str_yield = Form("Results/" + str_subfolder + "InvMassFit/%ibins/bin%i_signal.txt", nPtBins, iBin+1);
        ifs.open(str_yield.Data());
        // Read data from the file
        if(!ifs.fail()){
            ifs >> N_yield_val[iBin] >> N_yield_err[iBin];
        } else {
            PrintErr(str_yield);
            return;
        }
        ifs.close(); 
    } 
    Printf("2) N_yield loaded.");

    //#####################################################################################################
    // 3) Load AxE per pT bin
    for(Int_t iBin = 0; iBin < nPtBins; iBin++)
    {
        TString str_AxE = Form("Results/" + str_subfolder + "AxE_PtBins/AxE_%ibins.txt", nPtBins);
        ifs.open(str_AxE.Data());
        // Read data from the file
        if(!ifs.fail()){
            for(Int_t iBin = 0; iBin < nPtBins; iBin++){
                ifs >> i_bin >> AxE_val[iBin] >> AxE_err[iBin];
            }
        } else {
            PrintErr(str_AxE);
            return;            
        }
        ifs.close();
    }
    Printf("3) AxE loaded.");

    //#####################################################################################################
    // 4) Load FD corrections per pT bin
    TString str_FD = "Results/" + str_subfolder + "PtFit_NoBkg/RecSh4_fD.txt";
    ifs.open(str_FD.Data());
    // Read data from the file
    if(!ifs.fail()){
        Int_t i = 0;
        std::string str;
        while(std::getline(ifs,str)){
            istringstream in_stream(str);
            // skip first line
            if(i > 0) in_stream >> i_bin >> CorrFD_val[i-1] >> CorrFD_err[i-1];
            i++;   
        }
    } else {
        PrintErr(str_FD);
        return;
    }
    ifs.close();
    Printf("4) FD corrections loaded.");

    //#####################################################################################################
    // 5) Load FC corrections per pT bin
    TString str_FC = "Results/" + str_subfolder + "PtFit_NoBkg/RecSh4_fC.txt";
    ifs.open(str_FC.Data());
    // Read data from the file
    if(!ifs.fail()){
        Int_t i = 0;
        std::string str;
        while(std::getline(ifs,str)){
            istringstream in_stream(str);
            // skip first line
            if(i > 0) in_stream >> i_bin >> CorrFC_val[i-1] >> CorrFC_err[i-1];
            i++;   
        }
    } else {
        PrintErr(str_FC);
        return;
    }
    ifs.close();
    Printf("5) FC corrections loaded.");

    //#####################################################################################################
    // 6) Widths of intervals in pT^2 [GeV^2]
    for(Int_t iBin = 0; iBin < nPtBins; iBin++)
    {
        Pt2Widths[iBin] = TMath::Power(ptBoundaries[iBin+1], 2) - TMath::Power(ptBoundaries[iBin], 2);
    }
    Printf("6) Widths of pT^2 bins calculated.");

    //#####################################################################################################
    // Cross-check: print the loaded values
    Printf("Lumi: %.2f pm %.2f", Lumi_val, Lumi_err);
    Printf("pT_low\tpT_upp\tpT2_w\tN_val\tN_err\tAxE_val\tAxE_err\tfD_val\tfD_err\tfC_val\tfC_err");
    for(Int_t iBin = 0; iBin < nPtBins; iBin++)
    {
        Printf("%.3f\t%.3f\t%.4f\t%.1f\t%.1f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f",
            ptBoundaries[iBin], ptBoundaries[iBin+1], Pt2Widths[iBin], N_yield_val[iBin], N_yield_err[iBin], 
            AxE_val[iBin], AxE_err[iBin], CorrFD_val[iBin], CorrFD_err[iBin], CorrFC_val[iBin], CorrFC_err[iBin]);
    }

    //#####################################################################################################
    // Calculate the UPC cross section per bin
    for(Int_t iBin = 0; iBin < nPtBins; iBin++)
    {
        Sigma_UPC_val[iBin] = N_yield_val[iBin] / (
            (1.0 + CorrFD_val[iBin] / 100. + CorrFC_val[iBin] / 100.) * 
            (AxE_val[iBin] / 100.) * 
            (Eff_veto_val / 100.) * 
            (Eff_EMD_val / 100.) * 
            (Lumi_val * 1000) *
            BR_val * 
            RapWidth * Pt2Widths[iBin] );
        Sigma_UPC_err_stat[iBin] = Sigma_UPC_val[iBin] * N_yield_err[iBin] / N_yield_val[iBin];
    }

    //#####################################################################################################
    /*
    // Systematic uncertainties
    // Signal extraction
    TString str_ErrSystSigExtr = Form("Results/InvMassFit_SystUncertainties/%ibins/ErrSystSignalExtraction_%ibins.txt", nPtBins, nPtBins);
    ifs.open(str_ErrSystSigExtr.Data());
    if(!ifs.fail()){
        for(Int_t iBin = 0; iBin < nPtBins; iBin++){
            ifs >> i_bin >> ErrSyst_SigExtr[iBin];
        }
        ifs.close();
    } else {
        PrintErr(str_ErrSystSigExtr);
        return;        
    }
    // AxE MC
    for(Int_t iBin = 0; iBin < nPtBins; iBin++){
        ErrSyst_AxE[iBin] = AxE_err[iBin] / AxE_val[iBin] * 100.;
    }
    // fC, fD and total systematic uncertainty of sigma UPC
    Double_t CorrFD_upp[nPtBins] = { 0 };
    Double_t CorrFD_low[nPtBins] = { 0 };
    Double_t CorrFC_upp[nPtBins] = { 0 };
    Double_t CorrFC_low[nPtBins] = { 0 };
    Double_t Sigma_FD_upp[nPtBins] = { 0 };
    Double_t Sigma_FD_low[nPtBins] = { 0 };
    Double_t Sigma_FC_upp[nPtBins] = { 0 };
    Double_t Sigma_FC_low[nPtBins] = { 0 };
    for(Int_t iBin = 0; iBin < nPtBins; iBin++){
        CorrFD_upp[iBin] = CorrFD_sum_val[iBin] + CorrFD_sum_err[iBin];
        CorrFD_low[iBin] = CorrFD_sum_val[iBin] - CorrFD_sum_err[iBin];
        CorrFC_upp[iBin] = CorrFC_val[iBin] + CorrFC_err[iBin];
        CorrFC_low[iBin] = CorrFC_val[iBin] - CorrFC_err[iBin];
        Sigma_FD_upp[iBin] = Sigma_UPC_val[iBin] * (1.0 + CorrFD_sum_val[iBin] / 100. + CorrFC_val[iBin] / 100.) / (1.0 + CorrFD_upp[iBin] / 100. + CorrFC_val[iBin] / 100.);
        Sigma_FD_low[iBin] = Sigma_UPC_val[iBin] * (1.0 + CorrFD_sum_val[iBin] / 100. + CorrFC_val[iBin] / 100.) / (1.0 + CorrFD_low[iBin] / 100. + CorrFC_val[iBin] / 100.);
        Sigma_FC_upp[iBin] = Sigma_UPC_val[iBin] * (1.0 + CorrFD_sum_val[iBin] / 100. + CorrFC_val[iBin] / 100.) / (1.0 + CorrFD_sum_val[iBin] / 100. + CorrFC_upp[iBin] / 100.);
        Sigma_FC_low[iBin] = Sigma_UPC_val[iBin] * (1.0 + CorrFD_sum_val[iBin] / 100. + CorrFC_val[iBin] / 100.) / (1.0 + CorrFD_sum_val[iBin] / 100. + CorrFC_low[iBin] / 100.);
        Double_t Sigma_fD_upp_diff, Sigma_fD_low_diff, Sigma_fC_upp_diff, Sigma_fC_low_diff;
        Sigma_fD_upp_diff = TMath::Abs(Sigma_FD_upp[iBin] - Sigma_UPC_val[iBin]);
        Sigma_fD_low_diff = TMath::Abs(Sigma_FD_low[iBin] - Sigma_UPC_val[iBin]);
        Sigma_fC_upp_diff = TMath::Abs(Sigma_FC_upp[iBin] - Sigma_UPC_val[iBin]);
        Sigma_fC_low_diff = TMath::Abs(Sigma_FC_low[iBin] - Sigma_UPC_val[iBin]);
        ErrSyst_fD[iBin] = TMath::Max(Sigma_fD_upp_diff / Sigma_UPC_val[iBin], Sigma_fD_low_diff / Sigma_UPC_val[iBin]) * 100.;
        ErrSyst_fC[iBin] = TMath::Max(Sigma_fC_upp_diff / Sigma_UPC_val[iBin], Sigma_fC_low_diff / Sigma_UPC_val[iBin]) * 100.;

        Sigma_UPC_err_syst[iBin] = Sigma_UPC_val[iBin] * TMath::Sqrt(
            TMath::Power(ErrSyst_SigExtr[iBin] / 100., 2) +
            TMath::Power(ErrSyst_AxE[iBin] / 100., 2) +
            TMath::Power(ErrSyst_fD[iBin] / 100., 2) +
            TMath::Power(ErrSyst_fC[iBin] / 100., 2) +
            TMath::Power(ErrSyst_lumi / 100., 2) + 
            TMath::Power(ErrSyst_veto / 100., 2) + 
            TMath::Power(ErrSyst_EMD / 100., 2) + 
            TMath::Power(ErrSyst_tracks / 100., 2) + 
            TMath::Power(ErrSyst_CCUP31 / 100., 2) + 
            TMath::Power(BR_err / BR_val, 2)
        );
    }

    // Calculate the photonuclear cross section per bin
    for(Int_t iBin = 0; iBin < nPtBins; iBin++){
        Sigma_photo_val[iBin] = Sigma_UPC_val[iBin] / 2. / PhotonFlux_val * 1000;
        Sigma_photo_err_stat[iBin] = Sigma_UPC_err_stat[iBin] / 2. / PhotonFlux_val * 1000;
        Sigma_photo_err_syst[iBin] = Sigma_photo_val[iBin] * TMath::Sqrt(
            TMath::Power(Sigma_UPC_err_syst[iBin] / Sigma_UPC_val[iBin], 2) + 
            TMath::Power(ErrSyst_flux / 100., 2)
        );
    }

    // Load avg values of |t| per bin
    TString str_avgT = Form("DependenceOnT/output_%ibins.txt", nPtBins);
    ifs.open(str_avgT.Data()); 
    if(!ifs.fail()){
        Int_t i = 0;
        std::string str;
        while(std::getline(ifs,str)){
            Printf("Reading line %i: %s", i, str.data());
            istringstream istr(str);
            istr >> i_bin >> t_avg_val[i];
            i++;   
        }
        ifs.close();
    } else {
        PrintErr(str_avgT);
        return;         
    }
    Printf("6) Values of avg |t| values per bin loaded.");

    // Print results to the text file
    // 1a) Print the UPC cross section 
    TString str_out_1a = Form("Results/CrossSection/%ibins_FeedDown%i.txt", nPtBins, iFeedDown);
    ofstream fout_sigmaUPC(str_out_1a.Data());
    fout_sigmaUPC << Form("Lumi\terr\tRapW\tBR\terr\te_veto\terr\te_EMD\terr\tflux\terr\n")
                  << Form("%.1f \t%.1f \t%.1f \t%.3f \t%.3f \t%.1f \t%.1f \t%.1f \t%.1f \t%.1f \t%.1f \n\n",
                            LumiAll_val, LumiAll_err, 
                            RapWidth, 
                            BR_val*100., BR_err*100., 
                            Eff_veto_val, Eff_veto_err, 
                            Eff_EMD_val, Eff_EMD_err,
                            PhotonFlux_val, PhotonFlux_err);
    fout_sigmaUPC << Form("Bin\tPt2Low\tPt2Upp\tPt2_W\tN\terr\tAxE\terr\tFD [%%]\terr\tFC [%%]\terr\tsig\terr_sta\terr_sys\n");
    for(Int_t i = 0; i < nPtBins; i++){
        fout_sigmaUPC << std::fixed << std::setprecision(3)
                << i+1 << "\t"
                << ptBoundaries[i] * ptBoundaries[i] << "\t"
                << ptBoundaries[i+1] * ptBoundaries[i+1] << "\t"
                << std::fixed << std::setprecision(4)
                << Pt2Widths[i] << "\t"
                << std::fixed << std::setprecision(2)
                << N_yield_val[i] << "\t" << N_yield_err[i] << "\t"
                << AxE_val[i] << "\t" << AxE_err[i] << "\t"
                << std::fixed << std::setprecision(3)
                << CorrFD_sum_val[i] << "\t" << CorrFD_sum_err[i] << "\t"
                << CorrFC_val[i] << "\t" << CorrFC_err[i] << "\t"
                << std::fixed << std::setprecision(2)
                << Sigma_UPC_val[i] << "\t" << Sigma_UPC_err_stat[i] << "\t" << Sigma_UPC_err_syst[i] << "\n";
    }
    fout_sigmaUPC.close();
    Printf("Results printed to %s.", str_out_1a.Data()); 
    // 1b) Print the UPC cross section: TeX file
    TString str_out_1b = Form("Results/CrossSection/%ibins_FeedDown%i_TeX.txt", nPtBins, iFeedDown);
    ofstream fout_sigmaUPC_TeX(str_out_1b.Data());
    fout_sigmaUPC_TeX << Form("$%.0f", LumiAll_val) << R"( \pm )" << Form("%.0f$", LumiAll_err) << " &\t"
                      << Form("%.1f", RapWidth) << "\t"
                      << Form("$%.3f", BR_val*100.) << R"( \pm )" << Form("%.3f$", BR_err*100.) << " &\t"
                      << Form("$%.1f",Eff_veto_val) << R"( \pm )" << Form("%.1f$",Eff_veto_err) << " &\t"
                      << Form("$%.1f", Eff_EMD_val) << R"( \pm )" << Form("%.1f$", Eff_EMD_err) << " &\t"
                      << Form("$%.1f", PhotonFlux_val) << R"( \pm )" << Form("%.1f$", PhotonFlux_err) << R"( \\)" << "\n\n";
    for(Int_t i = 0; i < nPtBins; i++){
        fout_sigmaUPC_TeX << std::fixed << std::setprecision(3)
                          << "$(" << ptBoundaries[i] << "," << ptBoundaries[i+1] << ")$ & "
                          << std::fixed << std::setprecision(4)
                          << Pt2Widths[i] << " &\t$"
                          << std::fixed << std::setprecision(0)
                          << N_yield_val[i] << R"( \pm )" << N_yield_err[i] << "$ &\t$"
                          << std::fixed << std::setprecision(2)
                          << AxE_val[i] << R"( \pm )" << AxE_err[i] << "$ &\t$"
                          << std::fixed << std::setprecision(2)
                          << CorrFD_sum_val[i] << R"( \pm )" << CorrFD_sum_err[i] << "$ &\t$"
                          << std::fixed << std::setprecision(3)
                          << CorrFC_val[i] << R"( \pm )" << CorrFC_err[i] << "$ &\t$"
                          << std::fixed << std::setprecision(2)
                          << Sigma_UPC_val[i] << R"( \pm )" << Sigma_UPC_err_stat[i] << R"((stat.) \pm )" << Sigma_UPC_err_syst[i] << R"((syst.)$ \\)" << "\n";
    }                  
    fout_sigmaUPC_TeX.close();
    Printf("Results printed to %s.", str_out_1b.Data());

    // 2a) Print the systematic uncertainties
    TString str_out2 = Form("Results/CrossSection/%ibins_FeedDown%i_systematics.txt", nPtBins, iFeedDown);
    ofstream fout_systErr(str_out2.Data());
    fout_systErr << "All in percent\n";
    fout_systErr << "lumi \tveto \tEMD \ttracks \tCCUP31 \tBR \n"
                 << Form("%.1f \t%.1f \t%.1f \t%.1f \t%.1f \t%.1f \n\n",
                    ErrSyst_lumi, ErrSyst_veto, ErrSyst_EMD, ErrSyst_tracks, ErrSyst_CCUP31, ErrSyst_BR);
    fout_systErr << "Bin \tSigExt \tAxE MC \tfD \tfC \n";
    for(Int_t i = 0; i < nPtBins; i++){
        fout_systErr << i+1 << std::fixed << std::setprecision(1) << "\t"
                            << ErrSyst_SigExtr[i] << "\t"
                            << ErrSyst_AxE[i] << "\t"
                            << ErrSyst_fD[i] << "\t"
                            << ErrSyst_fC[i] << "\n";
    }    
    fout_systErr.close();
    Printf("Results printed to %s.", str_out2.Data());
    // 2b) Print the systematic uncertainties: TeX file
    TString str_out2b = Form("Results/CrossSection/%ibins_FeedDown%i_systematics_TeX.txt", nPtBins, iFeedDown);
    ofstream fout_systErr_TeX(str_out2b.Data());
    for(Int_t i = 0; i < nPtBins; i++){
        fout_systErr_TeX << std::fixed << std::setprecision(3)
                        << "$(" << ptBoundaries[i] << "," << ptBoundaries[i+1] << ")$ & "
                        << std::fixed << std::setprecision(1)
                        << ErrSyst_SigExtr[i] << " & "
                        << ErrSyst_AxE[i] << " & "
                        << ErrSyst_fD[i] << " & "
                        << ErrSyst_fC[i] << R"( \\)" << "\n";
                            
    }
    fout_systErr_TeX.close();
    Printf("Results printed to %s.", str_out2b.Data()); 

    // 3a) Print the photonuclear cross section (also an input for PhenoPredictions.c)
    TString str_out3a = Form("Results/CrossSection/%ibins_FeedDown%i_photo.txt", nPtBins, iFeedDown);
    ofstream fout_sigmaPhoto(str_out3a.Data());
    fout_sigmaPhoto << std::fixed << std::setprecision(4);
    fout_sigmaPhoto << "Bin \tt_low \tt_upp \tsig \terr_sta\terr_syst\n";
    for(Int_t i = 0; i < nPtBins; i++){
        fout_sigmaPhoto << i+1 << std::fixed << std::setprecision(4)
                               << "\t" << ptBoundaries[i] * ptBoundaries[i] << "\t" 
                               << ptBoundaries[i+1] * ptBoundaries[i+1] << "\t" 
                               << std::fixed << std::setprecision(1)
                               << Sigma_photo_val[i] << "\t"
                               << Sigma_photo_err_stat[i] << "\t"
                               << Sigma_photo_err_syst[i] << "\n";
    }
    fout_sigmaPhoto.close();
    Printf("Results printed to %s.", str_out3a.Data()); 
    // 3b) Print the photonuclear cross section: TeX file
    TString str_out3b = Form("Results/CrossSection/%ibins_FeedDown%i_photo_TeX.txt", nPtBins, iFeedDown);
    ofstream fout_sigmaPhoto_TeX(str_out3b.Data());
    for(Int_t i = 0; i < nPtBins; i++){
        fout_sigmaPhoto_TeX << std::fixed << std::setprecision(3)
                            << "$(" << ptBoundaries[i] * ptBoundaries[i] << "," << ptBoundaries[i+1] * ptBoundaries[i+1] << ")$ & "
                            << t_avg_val[i] << " &\t$"
                            << std::fixed << std::setprecision(1)
                            << Sigma_photo_val[i] << R"( \pm )" << Sigma_photo_err_stat[i] << R"((stat.) \pm )" << Sigma_photo_err_syst[i] << R"((syst.)$ \\)" << "\n";
    }
    fout_sigmaPhoto_TeX.close();
    Printf("Results printed to %s.", str_out3b.Data()); 
    */

    return;
}

void PrintErr(TString str){
    Printf("ERR: file %s missing. Terminating.", str.Data());
    return;
}